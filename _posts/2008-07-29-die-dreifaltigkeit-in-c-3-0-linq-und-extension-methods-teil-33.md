---
layout: post
section-type: post
title: Die Dreifaltigkeit in C# 3.0: λ, LINQ und Extension-Methods (Teil 3/3)
category: Unknown
tags: []
---
<p>Nachdem wir nun in Teil 1 und Teil 2 eine Menge Vorarbeit geleistet haben wird es nunmehr Zeit im dritten und letzten Teil dieser Serie zum eigentlichen Hauptthema zu kommen: Das <strong>L</strong>anguage <strong>In</strong>tegrated <strong>Q</strong>uery, kurz LINQ. Ohne Übertreibung kann man sagen, dass LINQ eines der umfangreichsten Sprach-Features der letzten Jahre im .NET-Framework ist und über kein Thema wurde seit Veröffentlichung so kontrovers diskutiert. LINQ bietet eine an den SQL-Syntax angelehnte Abfragemöglichkeit auf Listen an.</p>  <p>Nun haben wir ja bereits im vorherigen Abschnitt gelesen, dass man das auch mit den neuen Lambda-Expressions kann und <strong>intern werden alle LINQ-Queries auch in Lambda-Ausdrücke umgewandelt</strong>! Allerdings sind diese Abfragen dank des an SQL angelehnten Syntax leichter zu verstehen wenngleich auch nicht so mächtig wie die Lambda-Ausdrücke. So gibt es beispielsweise für das Zusammenfügen mehrerer Listen mittels <span style="font-family: courier new">Concat()</span> kein Äquivalent in LINQ und auch eine Entsprechung für die Aggregatfunktionen wie <span style="font-family: courier new">Count()</span>, <span style="font-family: courier new">Min()</span> oder <span style="font-family: courier new">Max()</span> fehlt.</p>  <div style="border-right: #000000 1px solid; padding-right: 4px; border-top: #000000 1px solid; padding-left: 4px; padding-bottom: 4px; border-left: #000000 1px solid; width: 523px; padding-top: 4px; border-bottom: #000000 1px solid; background-color: #cccccc">Es wurde auch die Möglichkeit implementiert LINQ auf Daten anzusetzen so dass Abfragen auf beispielsweise XML, DataSets oder SQL-Datenbanken möglich sind. Hier bietet einem LINQ sogar in der Datenbankvariante (LINQ to SQL) einen O/R-Mapper. Mit den sich hieraus ergebenden vielfältigen Möglichkeiten kann man ganze Bücher füllen, weswegen ich mich hier auf die Grundlagen von LINQ beim Zugriff auf Listen beschränken werde. Für weiterführende Informationen verweise ich auf entsprechende Fachliteratur.</div>  <br />  <div style="border-right: #000000 1px solid; padding-right: 4px; border-top: #000000 1px solid; padding-left: 4px; padding-bottom: 4px; vertical-align: top; border-left: #000000 1px solid; width: 523px; padding-top: 4px; border-bottom: #000000 1px solid; background-color: yellow">Obwohl viele Neuerungen sowohl für C# 3.0 als auch Visual Basic .NET 9.0 und bsp. Chrome 2.0 verfügbar sind, werde ich im Folgenden lediglich auf die Implementierung in C# eingehen. Als <acronym title="Integrated Development Environment">IDE </acronym>wurde die englische Version von Microsoft Visual Studio 2008 unter Vista SP1 und Windows XP SP3 eingesetzt. Die Beispiele sind allesamt in C# geschrieben und basieren auf der Version 3.5 des .NET-Frameworks.</div>  <hr />  <p>Die vollständige Serie habe ich auch in der Knowledge Base auf <a href="http://dotnet-forum.de/KnowledgeBase/articles/2008/07/29/317-grundlagen-zu-linq-lambda-expressions-und-extension-methods.aspx" target="_blank">www.dotnet-forum.de</a> in einem Artikel veröffentlicht. Hier findet der geneigte Leser auch noch zahlreiche Artikel von anderen Entwicklern und ein gut besuchtes Support-Forum für alle Aspekte der Programmierung mit dem .NET-Framework. Ein Besuch lohnt sich auf jeden Fall!</p>  <p>[more]</p>  <h2>LINQ</h2>  <h3>Einführung</h3>  <p>Greifen wir noch einmal auf unser erstes Beispiel mit Lambda-Ausdrücken zurück, in dem wir alle Personen ausgelesen haben deren Nachname mit einem „P“ beginnt und formulieren das dieses mal als LINQ-Query: </p>  <div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:9ff70652-b5f5-4837-a098-e9301cf37dea" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">List&lt;Person&gt; Adressbuch = PersonFactory.CreateRandomPeople( 100 );
List&lt;person&gt; Ergebnis = from person in this.Adressbuch
                        where person.LastName.StartsWith( "P" )
                        select person;</pre></div>

<p>Gehen wir auch diesen Ausdruck Schritt für Schritt durch: In Zeile 2 wird definiert auf welche Liste die LINQ-Abfrage ausgeführt werden soll (<font face="Courier New">this.Adressbuch</font>) und wie wir den Parameter nennen wollen, der ein einzelnes Element dieser Liste repräsentiert (<font face="Courier New">person</font>). Der Datentyp dieses Parameters muss hier nicht angegeben werden da er bereits hinreichend durch den Datentyp der Liste festgelegt ist.</p>

<p>Um nun unser Vergleichskriterium festzulegen verwenden wir die <font face="Courier New">where</font>-Klausel. Hierbei werden wir in Visual Studio 2008 von IntelliSense unterstützt. Als Ergebnis dieser Klausel erhalten wir eine Liste vom Datentyp<font face="Courier New"> IEnumerable&lt;Person&gt;</font>. Um nun festzulegen was wir vom LINQ-Query zurückgeliefert bekommen wird die <font face="Courier New">select</font>-Klausel verwendet; in unserem Beispiel also eine Sequenz von <font face="Courier New">person</font>-Objekten.</p>

<p>Es fällt auf, dass im Gegensatz zum bekannten SQL-Syntax die Reihenfolge der einzelnen Befehle etwas verdreht ist. So wird zunächst am Anfang definiert, was unsere Datenquelle ist und darauf dann diverse Operationen (<em>wie bsp. Filtern oder Sortieren</em>) angewendet. Erst am Schluß wird dann festgelegt in welcher Form diese Daten ausgegeben werden sollen. Diese Reihenfolge entspricht auch eher unserer Leserichtung. Es sei weiterhin angemerkt, dass der Kompiler die Schlüsselworte wie <font face="Courier New">from</font> und <font face="Courier New">select</font> nur innerhalb eines solchen LINQ-Queries interpretiert. Alter Code, in dem beispielsweise eine Variabel <font face="Courier New">from</font> genannt wurde, funktioniert also auch weiterhin; man sollte aber dennoch künftig auf eine solche Benennung zu Gunsten der Übersicht verzichten um Verwechslungen zu vermeiden.</p>

<h3>Die Operatoren</h3>

<p>LINQ besitzt im Vergleich zu den Lambda-Expressions nur wenige Operatoren. Das bedeutet im Umkehrschluß das man zwar jedes LINQ-Query auch als Lambda-Expression wiedergeben kann, umgekehrt jedoch (<em>wie bereits erwähnt</em>) nicht. Im folgenden werde ich die unterstützten Operatoren kurz mit ihrer jeweiligen Funktion vorstellen.</p>

<h4>from</h4>

<p>Wie bereits erwähnt wird in der <font face="Courier New">from</font>-Klausel die <strong>Datenquelle</strong> angegeben, auf welche die komplette Abfrage angewendet wird. Sie definiert also die <strong>Bereichsvariabel</strong>, die wir bei Lambda-Expressions vor dem Lambda-Operator ( <font face="Courier New">=&gt;</font> ) gefunden haben.</p>

<h4>where</h4>

<p>Um die Ergebnisse unserer Abfrage zu <strong>filtern</strong> wird dieser Operator verwendet. Mehrere Bedingungen können wie in C# üblich mit den Operatoren <font face="Courier New">&amp;&amp; </font>(<em>logisches UND</em>) bzw. <font face="Courier New">||</font> (<em>logisches ODER</em>) verknüpft werden.</p>

<h4>select</h4>

<p>Mittels der select-Klausel wird die <strong>Rückgabe</strong> des LINQ-Queries definiert. Sie entspricht somit der <font face="Courier New">Select()</font>-Anweisung bei den λ-Ausdrücken. Dem entsprechend ist es auch mit diesem Operator möglich entweder das ganze Element zurückzuliefern (bsp. <font face="Courier New">person</font>) oder entweder einen anderen bereits <strong>existierenden</strong> oder auch <strong>anonymen Datentyp</strong> mittels <strong>Projektion</strong>.</p>

<h4>orderby</h4>

<p>Mit Hilfe dieses Operators lässt sich die Ausgabe nach<strong> einem oder mehreren Kriterien sortieren</strong>. Hierbei werden ebenfalls die Schlüsselworte für eine <strong>aufsteigende</strong> (<font face="Courier New">ascending</font>, <em>der Standard</em>) bzw. eine <strong>absteigende</strong> (<font face="Courier New">descending</font>) Sortierung unterstützt: <font face="Courier New">orderby person.LastName, person.Age descending</font> (<em>zunächst eine aufsteigende Sortierung nach dem Nachnamen, anschließend absteigend nach dem Alter der jeweiligen Personen</em>).</p>

<h4>group</h4>

<p>Um meine Ergebnisse nach bestimmten Kriterien zu gruppieren kann man die group-Klausel verwenden. Sie entspricht in ihrer Funktion der GroupBy()-Methode, auf die ich bei den Lambda-Ausdrücken nicht näher eingegangen bin. Kurz zusammengefasst kann man sagen, dass das Resultat eine Liste aus <font face="Courier New">IGrouping&lt;K, V&gt;</font> Elementen ist. Der mit <font face="Courier New">K </font>bezeichnete Datentyp ist der <strong>Schlüssel</strong>, nach dem gruppiert wurde, und der mit <font face="Courier New">V</font> bezeichnete Datentyp ist der <strong>enthaltene Wert</strong> – also beispielsweise eine Liste mit <font face="Courier New">person</font>-Objekten. Zur Veranschaulichung ein einfaches Beispiel, bei dem wir das Resultat nach Postleitzahlen gruppieren: </p>

<div class="wlWriterSmartContent" id="scid:812469c5-0cb0-4c63-8c15-c81123a09de7:cde7ea07-de27-401a-985d-3f3ab730c7bf" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px"><pre name="code" class="c#:nocontrols">List&lt;Person&gt; Adressbuch = PersonFactory.CreateRandomPeople( 100 );
var Ergebnis = from item in this.Adressbuch
               group item by item.PLZ into ausgabe
               select ausgabe;</pre></div>

<p>Wir haben hier außerdem noch das Schlüsselwort <font face="Courier New">into</font> verwendet, um das Ergebnis der Gruppierung in einer temporären „<em>Variabeln</em>“ zu speichern damit wir später erneut bei der <font face="Courier New">select</font>-Klausel darauf zurückgreifen können.</p>

<h4>let</h4>

<p>Um weitere Unterabfragen innerhalb eines einzelnen Queries zu machen müssen die Abfrageergebnisse mit dem Operator <font face="Courier New">let</font> temporär zwischengespeichert werden um sie verwenden zu können. Man verwendet ihn in der Regel um Unterabfragen (<em>in SQL auch „<strong>Subselects</strong>“ genannt</em>) zu verknüpfen, für die sich der <font face="Courier New">join</font>-Operator nicht eignet (<em>siehe unten</em>) und wird hier nur der Vollständigkeit halber aufgeführt.</p>

<h4>join</h4>

<p>Genau wie die Methode <font face="Courier New">Join()</font> bei Lambda-Ausdrücken dient die <font face="Courier New">join</font>-Klausel dem Zusammenfügen mehrerer Ergebnisse zu einer resultierenden Liste, einen so genannten <strong>Equijoin</strong>. Hiermit bezeichnet man die <strong>Verknüpfung zweier Listen</strong> und nimmt als Grundlage die <strong>Gleichheit</strong> jeweils ein Elementes aus jeder Liste (<em>bsp. eine ID</em>). Diese Art von Vergleich ist vor allem in relationalen Datenbanken in der 2. oder 3. Ableitung häufig zu finden.</p>

<h3>Fazit </h3>

<p>Zunächst freut es mich, dass Sie bis hierher gekommen sind! Neben den relativ wenigen hier exemplarisch aufgeführten Punkten gibt es noch eine vielzahl weiterer Anwendungszwecke die für den geneigten Programmierer sicherlich interessant sind. Mein Ziel war es jedoch lediglich die rudimentären <strong>Grundlagen</strong> zu liefern und für das nötige Hintergrundwissen zu sorgen damit man überhaupt versteht was passiert wenn man eine LINQ-Abfrage startet. Ich hoffe das ich die hier erwähnten neuen Technologien von .NET 3.5 – allen voran natürlich LINQ – dem einen oder anderen schmackhaft machen konnte. Einige Bereiche habe ich dabei bewußt nur kurz angeschnitten um Einsteiger nicht hoffnungslos zu überfordern und interessierten Lesern einen Anreiz auf weitere Möglichkeiten zu bieten. Auf der Basis dieser Grundlagen kann man nun weiter experimentieren und sich mit den zahlreichen Erweiterungen (<em>LINQ to SQL, LINQ to XML, LINQ to Amazon,&#160; …</em>) vertraut machen die zwischenzeitlich entwickelt wurden.</p>

<h2>Programm-Tipp</h2>

<p>Wer gerne ein wenig mit LINQ-Abfragen oder Lambda-Ausdrücken experimentieren möchte dem empfehle ich das <strong>kostenlose Programm</strong>LINQPad von Joseph Albahari, über welches ich bereits berichtete. Das Programm ist recht klein und kommt als eine einzelne ausführbare Datei <strong>ohne eigene Installation</strong> aus – lädt also geradezu zum experimentieren ein. Ein <strong>Must-Have</strong> für jeden, der sich für LINQ &amp; co. interessiert!</p>

<h2>Buch-Tipp</h2>

<p>Im <strong>Addison Wesley Verlag</strong> ist im Juni 2008 das Buch <strong>Visual C# 2008</strong> von <strong>Frank Eller</strong> erschienen (<a href="http://www.addison-wesley.de/main/main.asp?page=aktionen/bookdetails&amp;ProductID=163410" target="_blank">ISBN: 978-3-8273-2641-6</a>). Mit seinen rund 1.300 Seiten und einem Preis von 49,95 Euro ist es sicher keine Lektüre für zwischendurch. Es wird jedoch auf sowohl die Grundlagen als auch die fortgeschrittenen Funktionen von C# 3.0 eingegangen. Allerdings empfehle ich dem gewillten Leser bereits ein wenig Erfahrung in Bezug auf Objektorientierung und die Programmierung im allgemeinen (<em>bsp. mit classic ASP oder auch Java</em>). Neueinsteiger ohne jede Vorkenntnis haben vor allem am Anfang eine recht hohe Lernkurve bei diesem Buch. <em>Einsteiger mit Vorkenntnissen, Umsteiger und fortgeschrittene Programmierer erhalten jedoch ein Praxis- und Nachschlagebuch, das sie bei der täglichen Arbeit mit C# begleitet </em>(so auf dem Buchrücken formuliert). Aus diesem Buch sind auch ein paar der in diesem Artikel genannten Beispiele entlehnt.</p>
