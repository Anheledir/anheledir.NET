---
layout: post
title: Gegen schwüle Entwicklung mit Interfaces und Typed Parameter
date: 2010-07-18 01:17
author: Gordon Breuer
comments: true
categories: [Development]
---
<p>Bei der Planung des letzten Kundenwebs stellte sich mal wieder die Aufgabe eine Navigation zu erstellen, die auf der Datenbank unseres eigenen <acronym title="Content Management System">CMS</acronym> ConLIVE! basiert. Jedes Web hat dabei eine eigene Datenbank, die jedoch auf einer größtenteils einheitlichen Tabellenstruktur basiert. Vor zwei Jahren entwickelten wir alle Webs noch mit classic <acronym title="Active Server Pages">ASP</acronym> und es existierte hierfür eine selbstgeschriebene Library mit Standartfunktionen, u.a. um besagte Navigation zu generieren. Inzwischen sind auch wir auf .NET-Programmierung umgestiegen, allerdings musste deshalb zunächst auch für jedes Web individuell das Auslesen und Zusammenstellen aller Daten erfolgen da die bisherige Library unbrauchbar geworden war. Eine eher “schwüle” Situation, von <acronym title="Don&#39;t Repeat Yourself">DRY</acronym> also keine Spur. Eine neue Library musste her!</p>  <p>In classic <acronym title="Active Server Pages">ASP</acronym> hatten wir in jedem Web die jeweilige Datenbank in der Variablen “db” initialisiert. Da die Tabellennamen und deren Struktur gleich sind konnten wir in der Library mit einfachen SQL-Anweisungen die Daten abrufen. Natürlich könnte man es ähnlich auch jetzt in .NET machen, andererseits bieten <acronym title="Object Relational">O/R</acronym>-Mapper wie Linq2Sql nicht zu Unterschätzende Vorteile, nicht zuletzt Intellisense, Typsicherheit und Syntaxkontrolle bereits zum Zeitpunkt des Kompilierens. Doch auch wenn die für unsere Anwendungszwecke benötigten Tabellennamen und -spalten unter den Webs identisch sind so werden doch immer mal individuelle Anpassungen vorgenommen. Im Falle von Linq2Sql bedeutet das, dass jedes Web seine eigene <acronym title="Database Markup Language">DBML</acronym>-Datei erhält und wir keine globale für alle Webs verwenden. Doch wie dann eine global verwendbare Bibliothek erstellen? Die Antwort waren für uns die oft unterschätzten Interfaces kombiniert mit Typed Parametern. [more]</p>  <p><a href="http://static.gordon-breuer.de/img/2587c089214e_C401/interface.png"><img style="border-right-width: 0px; margin: 0px 10px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="interface" border="0" alt="interface" align="left" src="http://anheledirwp.blob.core.windows.net/wordpress/2010/07/interface_thumb.png" width="244" height="133" /></a> Zunächst einmal ist es notwendig ein Interface der Klasse zu erstellen, welche bei Linq2Sql im DataContext die jeweilige Tabelle repräsentiert. Eine solche Schnittstelle enthält dabei lediglich die Signaturen von <abbr title="unter anderem">u.a. </abbr>den Methoden ohne die jeweilige Implementation. Mit den so definierten Eigenschaften kann man dann arbeiten ohne die eigentliche Klasse zu kennen: Die Tatsache, dass sie das Interface implementiert garantiert das Vorhandensein der definierten Methoden und Ereignisse. Um ein solches Interface zu erstellen setzen wir den Cursor innerhalb der gewünschten Klasse und drücken die Tastenkombination STRG+R STRG+I (<em>englisches Visual Studio 2010</em>) oder wählen alternativ im Kontextmenü “Refactor” – “Extract Interface…”. Im folgenden Dialog (<em>siehe Bild</em>) können die in das Interface zu übernehmenden Methoden <abbr title="et cetera">etc.</abbr> ausgewählt werden. Nach einem Klick auf “OK” wird Schnittstelle automatisch erstellt und der Klasse zugewiesen. Letzteres ist jedoch problematisch, da die vom Linq2Sql-Designer generierte CS-Datei jederzeit wieder neu erstellt werden könnte. Unsere Klasse würde dann das gerade erstellte Interface nicht mehr implementieren. Da alle Klassen jedoch automatisch als “partial” erstellt werden können wir unsere Interface-Implementierung einfach in eine neue Datei auslagern und die Änderungen der automatisch erstellten Klasse wieder verwerfen:</p>  <p><font face="Courier New">public partial class Dept : IDept { }</font></p>  <p>Ausser den Klassen, die den benötigten Tabellen entsprechen benötigen wir ausserdem, auch noch den DataContext den Linq2Sql angelegt hat. Auch hier erstellen wir uns wieder ein Interface, welches die Klassen beinhaltet die wir im vorherigen Schritt ebenfalls mit einer Schnittstelle implementiert haben:</p>  <p><font face="Courier New">public interface IDataContext {      <br />&#160;&#160;&#160; System.Data.Linq.Table&lt;Dept&gt; Depts { get; }       <br />}</font></p>  <p>Wenn wir die jeweiligen Interfaces in ein neues Projekt verschieben, welches unsere künftige Library repräsentiert, fällt schnell ein Problem auf: Hier ist die im Interface verwendete Klasse “Dept” unbekannt. Man könnte jetzt auf die Idee kommen hier einfach statt Dept das eben erstellte Interface IDept einzusetzen. Doch wenn wir dann in unserem Web dem Linq2Sql DataContext unser Interface zuweisen wie schon der partiellen Dept-Klasse zuvor bekommen wir eine Fehlermeldung: Der DataContext implementiert unser Interface nicht da dort “Depts” vom Typ “Table&lt;Dept&gt;” ist und eben nicht “Table&lt;IDept&gt;” wie von der Schnittstelle gefordert. Wir müssen also auch in IDataContext “Table&lt;Dept&gt;” verwenden.</p>  <p>Die Lösung ist ein typisierter Parameter für das Interface zu verwenden:</p>  <p><font face="Courier New">public interface IDataContext&lt;Dept&gt;      <br />&#160;&#160;&#160; where Dept : class, IDept {       <br />&#160;&#160;&#160; System.Data.Linq.Table&lt;Dept&gt; Depts { get; }       <br />}</font></p>  <p>Über die where-Bedingung geben wir an, dass Dept eine Klasse sein muss welche außerdem das Interface IDept implementiert. Jetzt können wir innerhalb unserer Library sowohl mit dem DataContext als auch mit der Dept-Tabelle über die Interfaces arbeiten:</p>  <p><font face="Courier New">public class ClDept&lt;TDept&gt;      <br />&#160;&#160;&#160; where TDept : class, IDept {       <br />      <br />&#160;&#160;&#160; private IDataContext&lt;TDept&gt; _db;       <br />      <br />&#160;&#160;&#160; public ClDept(IDataContext&lt;TDept&gt; db) {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; _db = db;       <br />&#160;&#160;&#160; }       <br />      <br />&#160;&#160;&#160; public string GetUrlFromDept(int idDept) {       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; var result = new StringBuilder();       <br />&#160;&#160;&#160;&#160;&#160;&#160; var dept = _db.Depts.SingleOrDefault(d =&gt; !d.Flg_del &amp;&amp; d.Id_dept.Equals(idDept));       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (dept.Equals(null))       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; throw new ArgumentOutOfRangeException(&quot;idDept&quot;, &quot;There is no dept entry with this id.&quot;);       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (dept.Id_dept_parent.HasValue)       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; result.Append(GetUrlFromDept((int)dept.Id_dept_parent));       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; result.Append(&quot;/&quot; + dept.Dept_name.CleanUrl());       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return result.ToString();       <br />&#160;&#160;&#160; }       <br />}</font></p>  <p>Innerhalb der Webseite können wir auf unsere ausgelagerte Funktion nun ebenfalls recht einfach zugreifen nachdem wir die <acronym title="Dynamic Link Library">DLL</acronym> referenziert haben. Zunächst müssen wir oben beschrieben die partiellen Klassen mit den Interfaces erweitert werden. Auf die Methode “GetUrlFromDept(int)” können wir ebenso einfach zugreifen:</p>  <p align="left"><font face="Courier New">var db = new Dms_meinweb(); //implementiert IDataContext&lt;Dept&gt;      <br />var navHelper = new ClDept&lt;Dept&gt;(db);       <br />string url = navHelper.GetUrlFromDept(25); // gibt bsp. “/Aktuelles/Veranstaltungen/Mainz” zurück</font></p>  <p>   <hr /><strong>Fazit</strong>: Schreibt man für eine im grunde identische Funktionalität den Quellcode mehrfach (<em>von der Copy-Pasta ganz zu schweigen</em>) macht man etwas verkehrt. Die <acronym title="Clean Code Developer">CCD</acronym> sprechen von der Verletzung des <acronym title="Don&#39;t repeat yourself">DRY</acronym>-Prinzips, doch egal wie man es nennt: Es ist fehleranfällig, mühsam bei einer Änderung überall anzupassen, unübersichtlich und schlußendlich genau so unangenehm wie schwül-warmes Sommerwetter! </p>  <a target="_blank" href="http://dotnet-kicks.de/kick/?url=http://old.gordon-breuer.de/post/2010/07/17/Gegen-schwule-Entwicklung-mit-Interfaces-und-Typed-Parameter.aspx&amp;title=Gegen schwüle Entwicklung mit Interfaces und Typed Parameter">
                    <img src="http://dotnet-kicks.de/Services/Images/KickItImageGenerator.ashx?url=http://old.gordon-breuer.de/post/2010/07/17/Gegen-schwule-Entwicklung-mit-Interfaces-und-Typed-Parameter.aspx" border="0" alt="Artikel empfehlen auf .NET-Kicks Deutschland" />
                  </a>
